/*
 * ===============================
 *  Required system / library headers
 * ===============================
 */

/*
 * <pcap.h>
 *  - Main libpcap header
 *  - Provides packet capture APIs such as:
 *      pcap_open_live()
 *      pcap_loop()
 *      pcap_compile()
 *      pcap_setfilter()
 *      pcap_breakloop()
 *  - Also defines structures like:
 *      struct pcap_pkthdr
 */
#include <pcap.h>

/*
 * <stdio.h>
 *  - Standard input/output library
 *  - Used here for printf() and fprintf()
 */
#include <stdio.h>

/*
 * <stdlib.h>
 *  - General utilities
 *  - Used for exit() and EXIT_FAILURE
 */
#include <stdlib.h>

/*
 * <signal.h>
 *  - Signal handling
 *  - Used to catch Ctrl+C (SIGINT)
 */
#include <signal.h>

/*
 * <string.h>
 *  - Memory utilities
 *  - Used for memcpy()
 */
#include <string.h>

/*
 * <arpa/inet.h>
 *  - Internet address conversion functions
 *  - Provides:
 *      struct in_addr
 *      inet_ntoa()  -> converts IP to string
 */
#include <arpa/inet.h>

/*
 * <netinet/if_ether.h>
 *  - Ethernet and ARP protocol definitions
 *  - Defines:
 *      struct ether_header
 *      struct ether_arp
 *      ETHERTYPE_ARP
 *      ARPOP_REQUEST
 */
#include <netinet/if_ether.h>


/*
 * ===============================
 *  Global variables
 * ===============================
 */

/*
 * Global pcap handle
 *
 * Why global?
 *  - The Ctrl+C signal handler must be able to access
 *    the pcap handle in order to stop packet capture.
 */
pcap_t *handle;


/*
 * ===============================
 *  Signal handler
 * ===============================
 */

/*
 * handle_sigint()
 *
 * This function is called automatically when the user presses Ctrl+C.
 *
 * SIGINT = "interrupt signal"
 * Usually generated by Ctrl+C in terminal.
 */
void handle_sigint(int sig) {
    /*
     * We do not actually need the signal number,
     * so we explicitly mark it as unused to avoid warnings.
     */
    (void) sig;

    /*
     * pcap_breakloop()
     *
     * This tells libpcap to immediately stop pcap_loop().
     * It causes pcap_loop() to return cleanly instead of
     * killing the program abruptly.
     */
    pcap_breakloop(handle);
}


/*
 * ===============================
 *  Packet processing callback
 * ===============================
 */

/*
 * arp_packet_handler()
 *
 * This function is called by libpcap for *every packet*
 * that matches the capture filter ("arp").
 *
 * Parameters:
 *  - user   : user-defined pointer (unused here)
 *  - header : packet metadata (timestamp, length, etc.)
 *  - packet : raw packet bytes
 */
void arp_packet_handler(
    u_char *user,
    const struct pcap_pkthdr *header,
    const u_char *packet
) {
    /*
     * We do not use these parameters, so suppress warnings.
     */
    (void) user;
    (void) header;

    /*
     * ===============================
     *  Ethernet header parsing
     * ===============================
     */

    /*
     * The Ethernet header is located at the very beginning
     * of the captured packet.
     *
     * We cast the raw packet pointer to struct ether_header
     * so we can access its fields easily.
     */
    struct ether_header *eth = (struct ether_header *) packet;

    /*
     * ether_type specifies what protocol is carried
     * inside the Ethernet frame.
     *
     * ETHERTYPE_ARP = 0x0806
     *
     * ntohs() is required because Ethernet headers
     * are transmitted in network byte order (big-endian).
     */
    if (ntohs(eth->ether_type) != ETHERTYPE_ARP)
        return;

    /*
     * ===============================
     *  ARP header parsing
     * ===============================
     */

    /*
     * The ARP header starts immediately after
     * the Ethernet header.
     *
     * sizeof(struct ether_header) is typically 14 bytes.
     */
    struct ether_arp *arp =
        (struct ether_arp *) (packet + sizeof(struct ether_header));

    /*
     * ar_op indicates whether this ARP packet is:
     *  - ARPOP_REQUEST (1)
     *  - ARPOP_REPLY   (2)
     *
     * We only want to observe ARP REQUESTS.
     */
    if (ntohs(arp->ea_hdr.ar_op) != ARPOP_REQUEST)
        return;

    /*
     * ===============================
     *  Extract IP addresses
     * ===============================
     */

    /*
     * ARP stores IP addresses as raw bytes (4 bytes).
     * We copy them into struct in_addr so we can
     * convert them into human-readable strings.
     */
    struct in_addr sender_ip, target_ip;

    /*
     * arp_spa = Sender Protocol Address (IPv4)
     * arp_tpa = Target Protocol Address (IPv4)
     */
    memcpy(&sender_ip, arp->arp_spa, sizeof(sender_ip));
    memcpy(&target_ip, arp->arp_tpa, sizeof(target_ip));

    /*
     * ===============================
     *  Print ARP information
     * ===============================
     */

    /*
     * Print a label so the output is readable.
     */
    printf("ARP REQUEST:\n");

    /*
     * Print sender MAC address.
     *
     * arp_sha = Sender Hardware Address (MAC)
     * MAC addresses are 6 bytes long.
     */
    printf("  Sender MAC : %02x:%02x:%02x:%02x:%02x:%02x\n",
           arp->arp_sha[0], arp->arp_sha[1], arp->arp_sha[2],
           arp->arp_sha[3], arp->arp_sha[4], arp->arp_sha[5]);

    /*
     * inet_ntoa()
     *  - Converts IPv4 address from binary form
     *    to dotted-decimal string.
     */
    printf("  Sender IP  : %s\n", inet_ntoa(sender_ip));
    printf("  Target IP  : %s\n", inet_ntoa(target_ip));

    /*
     * Separator for readability.
     */
    printf("----------------------------------------\n");
}


/*
 * ===============================
 *  Program entry point
 * ===============================
 */

int main(int argc, char *argv[]) {
    /*
     * Buffer for libpcap error messages.
     */
    char errbuf[PCAP_ERRBUF_SIZE];

    /*
     * Structure to hold the compiled BPF filter.
     */
    struct bpf_program fp;

    /*
     * Capture filter expression.
     *
     * "arp" tells libpcap to capture only ARP packets.
     */
    char filter_exp[] = "arp";

    /*
     * Network mask (not used here, so set to 0).
     */
    bpf_u_int32 net = 0;

    /*
     * ===============================
     *  Command-line argument check
     * ===============================
     */

    /*
     * The user must specify the network interface name.
     * Example:
     *   ./arp_sniffer eth0
     */
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <interface>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    /*
     * ===============================
     *  Open network interface
     * ===============================
     */

    /*
     * pcap_open_live()
     *
     * Parameters:
     *  - interface name (e.g. eth0)
     *  - BUFSIZ: max bytes per packet to capture
     *  - 1: enable promiscuous mode
     *  - 1000: read timeout in milliseconds
     *  - errbuf: buffer for error messages
     */
    handle = pcap_open_live(
        argv[1],
        BUFSIZ,
        1,
        1000,
        errbuf
    );

    /*
     * Check if opening the interface failed.
     */
    if (!handle) {
        fprintf(stderr, "pcap_open_live failed: %s\n", errbuf);
        exit(EXIT_FAILURE);
    }

    /*
     * ===============================
     *  Compile capture filter
     * ===============================
     */

    /*
     * pcap_compile()
     *
     * Converts the human-readable filter ("arp")
     * into BPF bytecode that runs in kernel space.
     */
    if (pcap_compile(handle, &fp, filter_exp, 0, net) == -1) {
        fprintf(stderr, "pcap_compile failed: %s\n",
                pcap_geterr(handle));
        pcap_close(handle);
        exit(EXIT_FAILURE);
    }

    /*
     * ===============================
     *  Apply capture filter
     * ===============================
     */

    /*
     * Attach the compiled filter to the interface.
     */
    if (pcap_setfilter(handle, &fp) == -1) {
        fprintf(stderr, "pcap_setfilter failed: %s\n",
                pcap_geterr(handle));
        pcap_close(handle);
        exit(EXIT_FAILURE);
    }

    /*
     * ===============================
     *  Register signal handler
     * ===============================
     */

    /*
     * Register handle_sigint() to be called
     * when Ctrl+C (SIGINT) is received.
     */
    signal(SIGINT, handle_sigint);

    /*
     * Inform the user that capture has started.
     */
    printf("Sniffing ARP requests on interface %s...\n", argv[1]);
    printf("Press Ctrl+C to stop.\n\n");

    /*
     * ===============================
     *  Start packet capture loop
     * ===============================
     */

    /*
     * pcap_loop()
     *
     * Parameters:
     *  - handle: capture session
     *  - -1: capture packets indefinitely
     *  - arp_packet_handler: callback function
     *  - NULL: user data passed to callback
     */
    pcap_loop(handle, -1, arp_packet_handler, NULL);

    /*
     * Execution reaches here only after
     * pcap_breakloop() is called.
     */
    printf("\nStopped sniffing.\n");

    /*
     * Close the capture handle and free resources.
     */
    pcap_close(handle);

    return 0;
}
